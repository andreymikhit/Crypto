# Crypto
# Криптография

### Урок 1. Введение в курс
#### Задание 1
Одна из кодировок не разбиралась на уроке и чтобы ее раскодировать нужно немного поискать.
В этом задании вам необходимо “расшифровать” 5 “шифротекстов”:

```CMD
WW91IGRpZCBpdCE=
S2VlbiBvbiBnb2luZyE=
VG9wIHNlY3JldCBpbmZvcm1hdGlvbiBpcyBuZWFyIHlvdS4u
KRUGC5BAO5QXGIDUOJUWG23ZEBXW4ZJB
Q29uZ3JhdHVsYXRpb25zISBZb3UndmUgJ2RlY3J5cHRlZCcgYWxsIG1lc3NhZ2VzIQ==
```
В результате вы получите 5 осмысленных фраз на английском языке.

Задание 2
“Расшифруйте” следующие “шифротексты”:
```CMD
4c6f72656d20497073756d2069732073696d706c792064756d6d792074657874206f6620746865207072696e74696e6720616e64207479706573657474696e6720696e6475737472792e
436865636b206f757420746869732074616c6b20696620796f75206861766e277420646f6e6520736f2068747470733a2f2f7777772e796f75747562652e636f6d2f77617463683f763d6d4b535136446a427a3377
```
В результате вы получите осмысленные фразы на английском языке.

Задание 3
Во всех последующих заданиях вы будете работать с “сырыми” байтами. Однако у большей части байт нет соответствующего печатного символа (например, 0x00 будет в лучшем случае напечатан как пробел), поэтому данные для заданий будут даваться в кодировках base64 и hex.

Следовательно, очень полезно научиться кодировать и декодировать их на вашем любимом языке программирования.

Декодируйте строку:
```CMD
49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d
```
Результат представьте в base64. На выходе должно получиться:
```CMD
SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t
```
Задание взято из http://cryptopals.com/sets/1/challenges/1

Задание 4
Напишите функцию, которая принимает на вход две последовательности байт одинаковой длины и возвращает их побайтовый XOR.

Ваша функция работает правильно, если приняв на вход hex-декодированные
```CMD
1c0111001f010100061a024b53535009181c
```
и
```CMD
686974207468652062756c6c277320657965
```
вернет hex-декодированное значение
```CMD
746865206b696420646f6e277420706c6179
```
В следующем здании мы будем искать уязвимости в нашем свежеиспеченном шифре!

Задание взято из http://cryptopals.com/sets/1/challenges/2

Задание 5
Hex-кодированная строка

1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736

была зашифрована Single-byte XOR-ом.

Ваша задача найти ключ шифрования и расшифровать сообщение. Как? Придумайте метрику для оценки открытого текста (частотное распределение символов - хорошая метрика), оцените каждый открытый текст по этой метрике и выберите текст с лучшим показателем.

Примечание: вы можете сделать это задание вручную, но так делать не стоит, напишите программу и пусть она сделает это за вас.

Задание взято из http://cryptopals.com/sets/1/challenges/3

Задание 6
Одна из строк в файле 6.txt зашифрована Single-byte XOR-ом. Найдите ее (программа из задания 5 поможет вам).

Задание взято из http://cryptopals.com/sets/1/challenges/4

Задание 7
В этом задании вам необходимо реализовать Repeating-key XOR. Зашифруйте следующие строки на ключе ICE:
```CMD
Burning 'em, if you ain't quick and nimble
I go crazy when I hear a cymbal
```
В результате у вас получится шифротекст:
```CMD
0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20
0063222663263b223f30633221262b690a652126243b632469203c24212425
```
Задание взято из http://cryptopals.com/sets/1/challenges/5

Задание 8 (*)
В этот раз мы (традиционно) взломаем шифр, который создали в предыдущем задании.

Вам необходимо расшифровать файл 8.txt. Он был закодирован в base64 после применения repeating-key XOR. Используйте следующий алгоритм:

Шаг 1. Определить длину ключа KEYSIZE (подсказка, значение ключа лежит в диапазоне от 2 до 40).

Напишите функцию, которая вычисляет расстояние Хэмминга между двумя строками. Расстояние Хэмминга это количество отличающихся бит в строках. Расстояние между this is a test и wokka wokka!!! равно 37. Убедитесь, что ваша функция возвращает такой же результат.
Для каждого KEYSIZE:
Возьмите первые KEYSIZE байт и вторые KEYSIZE байт.
Найдите расстояние между ними.
Нормализуйте результат, поделив его на KEYSIZE.
У вас будет несколько наименьших значений KEYSIZE. У вас есть два варианта: попробовать все наименьшие значения или взять 4 (6, 8, …) KEYSIZE блоков вместо 2-ух и усреднить полученные значения.

Шаг 2. Теперь вы знаете длину ключа. Найдите ключ.

Разбейте шифротекст на блоки длины KEYSIZE.
Транспонируйте блоки: сделайте новый блок, состоящий из 1-ого байта каждого старого блока, второй новый блок состоящий из 2-ого байта каждого старого блока и так далее.
Взломайте каждый новый блок как single-byte XOR. У вас уже есть код для этого!
Для каждого блока выберите однобайтовый ключ, у которого частотное распределение открытого текста наиболее близко к английскому тексту. Соберите однобайтовые ключи вместе (ключ первого блока - первый байт искомого ключа, ключ второго блока - второй байт искомого ключа и так далее) и вы получите искомый ключ!

Эта задача носит скорее образовательный характер (вряд ли вы встретите repeating-key XOR в реальной жизни), но концепции, которые в ней применяются, помогут вам в понимании и поиске реальных криптографических уязвимостей.

Многие из специалистов по информационной безопасности знают как взломать repeating-key XOR, но мало кто может взломать его на практике. Вы - можете.

Задание взято из http://cryptopals.com/sets/1/challenges/


### Урок 2. Симметричная криптография
Задание 1
Файл 1.txt зашифрован с помощью AES-128 в режиме ECB на ключе YELLOW SUBMARINE и закодирован в base64. Примечание: буквы ключа заглавные, длина ровно 16 символов (байт) - замечательный ключ для AES-128.

Дешифруйте файл. В конце концов у вас есть ключ. Проще всего использовать OpenSSL::Cipher в режиме AES-128-ECB, но это не наш путь. Мы должны реализовать режим ECB сами, это пригодится нам в дальнейшем.

Хорошая новость в том, что для этого не нужно писать AES-128 с нуля. Мы сделаем AES-128 из подручных средств. На Python функция дешифрования будут выглядеть примерно так:

```
def aes128_decrypt(block, key):
if len(block) != 16:
return None

cipher = AES.new(key, AES.MODE_ECB)
return cipher.decrypt(block)
[]()
http://cryptopals.com/sets/1/challenges/7
[]()
**Задание 2**
В файле 2.txt находится несколько шифротекстов. Один из них был зашифрован в режиме ECB. Найдите его.
[]()
Помните, в чем основная проблема режима ECB? Одинаковые 16 байт открытого текста дают одинаковые 16 байт шифротекста.
[]()
http://cryptopals.com/sets/1/challenges/8
[]()
**Задание 3**
Реализуйте PKCS#7 паддинг, который будет дополнять блок до заданной длины. У вас должна получиться функция `pkcs7_padding(block, target_length)`.
[]()
Для примера, `pkcs7_padding(“YELLOW SUBMARINE”, 20)` вернет `YELLOW SUBMARINE\x04\x04\x04\x04`.
[]()
http://cryptopals.com/sets/2/challenges/9
[]()
**Задание 4**
Реализуйте функции шифрования и дешифрования AES-128 в режиме CBC (используйте код из задания 1). Дешифруйте файл 4.txt с помощью ключа `YELLOW SUBMARINE` и вектора инициализации, состоящего из нулей `\x00\x00\x00...`.
[]()
http://cryptopals.com/sets/2/challenges/10
[]()
**Задание 5**
К этому моменту у вас должны быть готовы ECB и CBC режимы AES.
[]()
Напишите функцию, которая генерирует случайный ключ (16 байт из /dev/urandom).
[]()
Напишите функцию, которая берет случайный ключ и шифрует с его помощью открытый текст. Функция будет выглядеть как `encryption_oracle(your-input)` и возвращать шифротекст.
[]()
Также функция-оракул должна присоединять 5-10 (число выбирается случайно) рандомных байт перед открытым текстом и 5-10 рандомных байт после открытого текста.
[]()
Пусть функция-оракул в половине случаев шифрует в режиме ECB, а в другой половине случаев в режиме CBC (режим выбирается случайным образом).
[]()
Вам нужно написать программу, которая примет на вход шифротекст и будет способна определить какой из режимов шифрования был использован (ECB или CBC). Примечание: вы можете подавать на вход функции-оракула открытый текст произвольной длины.
[]()
http://cryptopals.com/sets/2/challenges/11
[]()
**Задание 6**
Модифицируйте функцию `encryption_oracle` из задания 5 так, чтобы она шифровала только в режиме ECB на случайном ключе, который остается одинаковым в пределах запуска программы (например, сделайте глобальную переменную KEY и берите значение из os.urandom).
[]()
Функция будет добавлять к открытому тексту base64-декодированное значение (это нужно сделать до шифрования):
[]()
Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg
aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq
dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg
YnkK

[]()
Внимание! Не декодируйте это значение. Суть задания в том, что вы не знаете что внутри base64.
[]()
В итоге ваша функция будет возвращать значение:
[]()

AES-128-ECB(ваша-строка || неизвестная-строка, случайный-ключ)
```

В такой схеме вы можете восстановить содержимое неизвестной строки, сделав несколько запросов к функции-ораклу! Алгоритм выглядит примерно так:

Шаг 1. Узнайте размер блока (вы уже его знаете, но все равно выполните этот шаг). Для этого подавайте на вход строки из одинаковых байт, каждый раз добавляя по одному байте: “A”, “AA”, “AAA” и так далее. Подумайте о том, в какой момент вы сможете точно определить длину блока.

Шаг 2. Поймите, что функция использует ECB режим шифрования. Вам это уже известно, но все равно выполните этот шаг.

Шаг 3. Создайте блок данных, длина которого в точности на единицу меньше длины блока (например, если длина блока 8, то блок данных будет “AAAAAAA”). Задайтесь вопросом: что функция шифрования поставит на позицию последнего байта?

Шаг 4. Подавайте на вход функции-оракула все возможные значения последнего байта (“AAAAAAAA”, “AAAAAAAB”, “AAAAAAAC” и так далее). Запомните первый блок каждого получившегося шифротекста.

Шаг 5. Возьмите блок шифротекста из шага 3 и найдите его в списке из шага 4. Теперь вы знаете первый байт неизвестной строки.

Шаг 6. Повторите алгоритм для второго и последующих байт.

http://cryptopals.com/sets/2/challenges/12


### Урок 3. Криптографические хеш-функции
Задание 1
Необходимо для каждой строки получить хеши с помощью алгоритмов: sha256, bcrypt (с солью '$2b$15$NSVH/I.9u1l/WoYUd/sSI.') и md5.

```
08122988399
nampoly2537
lasabre97
as534031
Victor_
16MSTF68AYSL
hhrules
cpt704242
gracemac
rayas123123
```

Для выполнения задания используйте библиотеки вашего языка программирования (например, для Python это будут hashlib и bcrypt).

Задание 2
Найдите исходные значения каждого из хешей:

```
23f6121371ef7563ec479de345c9e479
7351a8f9d143de67724772ea1a7e7e82d068cb77c3f495d5d234083d686c1226
cf9baae799c1d9164d2b6c37acf8562d
ae6a4840fe4e29991483c8a4115451d105e2e057e6870279c15c211d3375546f
004a602d9e890b00
9407cad0b776fd5f614649eddff47eefc71aa82d
e0728635632956dd3d28e0b9c28bf97735de32c3
3bb0d8c10c4ce5561daa0d82ee65d692a9d70276f7e53006aa5c4ad34aee1c13
9f00e35c7729cdac242e86051a57020d
6650ee0bf5af2a915618beb0361e67c04cedd4ea0c00d68ea72b16866c62dd16
eead40c59c83c69bdd2505ac081e09c0354345e2
7d63b6cbbed434353836dc011701321ac4827b6d
f1df20f71e680534
8a99ad26f053411a73104bfe0f1e19193efd5587eefd84bda435ed92397850d1
78dd2b61c96e895035c87528b5c3e2a9
b3dab40f3d51065754e4f0ef0d20039d
c9203499e3a2ff2b1244913777a3614954c1cd17240695fc160fe96914094912
8e82dfe15d36d6ec75f38de62128cf386964bf80b423ccda4fd239fc942d2cd9
43ca9303ecf07627
3ad12414555b1e01870647cb4dc99df88dbdd7eaf1494900fa9dd89bb2758cb3
```

Для выполнения задания разрешается использовать любые методы.

Задание 3
В файле leak_db.txt находятся хеши паролей из скомпрометированной базы данных. Вам необходимо восстановить все пароли из базы данных. Известно, что пароли словарные.


### Урок 4. Message Authentication Code
Задание 1
Напишите небольшое веб-приложение, используя готовый фреймворк (web.py, Sinatra, …). В этом приложении будет один эндпойнт, который принимает на вход имя файла и подпись.


http://localhost:9000/test?file=foo&signature=46b4ec586117154dacd49d664e5d63fdc88efb51


Сервер при получении подобного запроса будет брать HMAC (функцию HMAC реализуйте самостоятельно) от файла foo и сверять полученное значение со значением signature. Если значения совпадут, то сервер покажет файл, иначе сервер вернет ошибку.

Теперь напишите функцию insecure_compare, которая побайтово сравнивает строки и реализует “ранний выход” (т.е. возвращает False на первой паре не совпавших байт). В цикле insecure_compare добавьте искусственную задержку в 50 мс (например, функцией time.sleep(0.05) в Python).

Для проверки подписи используйте insecure_compare вместо обычной функции сравнения.

Используя факт задержек и раннего выхода, напишите программу, которая будет подбирать валидную подпись для любого файла (без знания ключа!).

В реальном мире подобные уязвимости тяжело эксплуатировать из-за задержек в сети. Однако это хороший пример атаки по сторонним каналам и похожие уязвимости время от времени встречаются в CTF-ах. Например, в 50m-ctf (https://ajxchapman.github.io/security/2019/03/26/h1-702-ctf-2019.html) от HackerOne была очень похожая уязвимость.

http://cryptopals.com/sets/4/challenges/31

Задание 2
Найдите реализацию SHA-1 на вашем языке программирования (например, можно использовать https://github.com/ajalt/python-sha1 для Python). Примечание: это задание является подготовкой к атаке Hash Length Extension, поэтому нужна именно чистая реализация SHA-1, а не библиотечная.

Напишите функцию, которая будет реализовывать MAC вида SHA1(key || message), где || - конкатенация.

Убедитесь, что вы не можете подделать сообщение, не изменив при этом MAC.

http://cryptopals.com/sets/4/challenges/28

Задание 3 (*)
Напишите функцию, которая производит MD паддинг для произвольного сообщения. Проверьте, что написанная вами функция генерирует такой же паддинг как и функция во взятой вами реализации SHA-1.

Возьмите MAC сообщения, которое вы хотите подделать (это просто SHA-1 хеш). Разбейте хеш на 32-битные регистры SHA-1 (a, b, c, d, e).

Измените реализацию SHA-1 так, чтобы при вызове можно было передать новый значения для регистров a, b, c, d, e (обычно они заполнены магическими числами).

Реализуйте атаку Hash Length Extension - сгенерируйте MAC для строки comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon со случайным ключом (ключ можно взять из /usr/share/dict/words; используйте его только для генерации исходного MAC). Подделайте сообщение, чтобы оно заканчивалось на ;admin=true.


http://cryptopals.com/sets/4/challenges/29


### Урок 5. Асимметричная криптография и другие темы
Это относительно простое домашнее задание освежит некоторые темы и подготовит вас к тесту.

Задание 1
В этом задании вам необходимо “расшифровать” 4 “шифротекста”:
```
SXQncyBiYXNlNjQK
497473206120686578
SGksIE1hcmlhLiBIb3cgYXJlIHlvdT8K
KVXGK6DQMVRXIZLEEBSW4Y3PMRUW4ZZOEBBHK5BAPFXXKIDENFSCA2LUFQQHE2LHNB2D6CQ=
```

Задание 2
Ниже представлены хеши некоторых словарных паролей. Найдите их исходные значения (сами пароли).
```
8cca64749f22aa0c1925c2e21e452f4fd33b0ce11d9dc9a5cabd244458f34089
2ddf70ab0eed47a05a45bfc44707dfad
512c3550c043c07d4419bcf4bcd5bdab748d4586
e12bd29bb98030b862c06ee56bd5b06b
990dc51251a5294891871d427a90595fd86fbd0d
df7371d70cd17e473fded3938fb3cf922e6f2130
dbfef27b3d5ec5ea19127faf280a7e995a0da72a
eb0d6a426fcbae4c825c513f45440ea3c8d35132
cb0367405622a39bdcfd2f5bb7e7ef326857693b
```

Задание 3
Найдите приватную часть RSA ключа в приложенном репозитории requests.tgz. Подсказка: сперва узнайте формат RSA ключей, а затем вы можете найти ключ руками или с помощью программы https://github.com/dxa4481/truffleHog.
